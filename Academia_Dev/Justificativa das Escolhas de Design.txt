Justificativa das Escolhas de Design do Projeto AcademiaDev

Nós decidimos implementar a hierarquia de usuários através de uma classe abstrata `User` porque queríamos evitar duplicação de código entre `Student` e `Admin`, já que ambos compartilham atributos básicos como nome, email e senha. Fizemos a classe `User` abstrata para garantir que ela não pudesse ser instanciada diretamente, forçando o uso das subclasses específicas. Esta abordagem nos permitiu centralizar a lógica comum de validação e comparação, facilitando futuras manutenções e a adição de novos tipos de usuários sem reescrever código já testado.

Para o sistema de planos de assinatura, nós optamos por uma interface `SubscriptionPlan` ao invés de herança porque queríamos máxima flexibilidade na implementação das regras de negócio. Fizemos assim porque cada plano tem comportamentos muito específicos - o `BasicPlan` limita a 3 matrículas enquanto o `PremiumPlan` é ilimitado, e uma interface nos dá liberdade total para implementar essas regras sem herdar comportamentos desnecessários. Além disso, esta escolha facilita a criação de novos planos no futuro, como um possível plano corporativo, sem impactar o código existente.

Nós separamos a lógica de negócio em classes de serviço (`CourseService`, `EnrollmentService`, etc.) porque queríamos manter as classes de modelo focadas apenas na representação de dados. Fizemos esta separação seguindo o princípio de responsabilidade única - cada classe de serviço tem uma responsabilidade específica e bem definida. Esta arquitetura nos permite testar a lógica de negócio independentemente dos modelos de dados e facilita a manutenção, já que mudanças nas regras de negócio ficam isoladas nas classes de serviço.

Nós implementamos a classe `Enrollment` como uma entidade própria ao invés de usar apenas coleções nas classes `Student` e `Course` porque precisávamos armazenar informações específicas da matrícula, como progresso e data de inscrição. Fizemos assim para representar corretamente o relacionamento many-to-many com atributos adicionais. Para o sistema de suporte, escolhemos usar uma `Queue` para os tickets porque queríamos garantir que eles fossem processados na ordem de chegada, proporcionando um atendimento justo aos usuários. Os enums `CourseStatus` e `DifficultyLevel` foram nossa escolha para garantir type safety e evitar valores inválidos no sistema.